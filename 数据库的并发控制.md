## 一、数据库的并发控制

<font color=red>**主要考点：**</font>

```markdown
	1、事务调度
	2、并发操作带来的问题
	3、并发调度的可串行性
	4、并发控制技术
	5、两段锁协议
	6、事务的隔离级别
```

#### 1、事务调度

​	**1、串行调度：**是指多个事务依次串行执行，且只有当一个事务的所有操作都执行完成才执行另一个事务的所有操作。

```markdown
	例：有两个事务  $T_0和T_1$，事务$T_0$从账号$A$转2000元到账户$B$；事务$T_1$从账户$A$转$20%$。$T_0和T_1$的定义如下所示。
```

|   $T_0$   |    $T_1$    |
| :-------: | :---------: |
| read(A);  |  read(A);   |
| A=A-2000; | temp=A*0.2; |
| write(A); | A:=A-temp;  |
| read(B);  |  write(A);  |
| B=B+2000: |   read(B)   |
| write(B)  |  B=B+temp   |
|           |  write(B)   |



​	**2、并发调度：**利用分时的方法同时处理多个事务。

```markdown
	并发调度执行的结果与一次串行调度执行的结果相同，则称这个并发调度是正确的。
```

![屏幕截图 2025-04-25 131857](D:\屏幕截图 2025-04-25 131857.png)

​	

​	**3、可恢复调度与不可恢复调度**（了解）

​		指满足这样的条件的调度：当事务$T_j$要读事务$T_i$写的数据时，$T_i$事务必须要先于事务$T_j$提交。

例：以下不可恢复调度举例

| 时间 | $T_0$          | $T_1$        |
| ---- | -------------- | ------------ |
| t1   | read(A);       |              |
| t2   | write(A);      |              |
| t3   |                | read(A);     |
| t4   |                | /\*COMMIT\*/ |
| t5   | read(B);       |              |
| t6   | /\*ROLLBACK\*/ |              |

 

#### 2、并发操作代理的问题

- 并发操作带来的数据不一致性有三类：**丢失修改、不可重复读和读脏数据。<font color=red>主要原因是事务的并发操作破坏了事务的隔离性。</font>**

  1. **丢失修改：**<span style='background-color:yellow'>两个事务对同一个数据进行修改，导致事务A对数据库的修改被事务B的修改所覆盖。</span>

     | 时间 | $T_1$        | $T_2$        |
     | ---- | ------------ | ------------ |
     | t1   | read(A)[16]  |              |
     | t2   |              | read(a)[16]  |
     | t3   | A=A-1[15]    |              |
     | t4   |              | A=A-1[15]    |
     | t5   | write(A)[15] |              |
     | t6   |              | write(A)[15] |

     

  2. **不看重复读：**事务对同一数据进行两次读取的结果不同。原因是两次读取的间隙数据被另一事务修改了。

     | 时间 | $T_1$                      | $T_2$         |
     | ---- | -------------------------- | ------------- |
     | t1   | read(A)[50]                |               |
     | t2   | read(B)[100]               |               |
     | t3   | C=A+B[150]                 |               |
     | t4   |                            | read(B)[100]  |
     | t5   |                            | B=B*2[200]    |
     | t6   |                            | write(B)[200] |
     | t7   | read(A)[50]                |               |
     | t8   | read(B)[200]               |               |
     | t9   | C=A+B[250]<br />(验算不对) |               |

     

  3. **读脏数据：**某事务读取的数据是其他事务修改后的值，但该修改后来又被撤销了。

     | 时间 | $T_1$             | $T_2$        |
     | ---- | ----------------- | ------------ |
     | t1   | read(C)[100]      |              |
     | t2   | C=C*2[200]        |              |
     | t3   | write(C)[200]     |              |
     | t4   |                   | read(C)[200] |
     | t5   |                   |              |
     | t6   |                   |              |
     | t7   | ROLLBACK（C=100） |              |

     

  4. **幻读：**也称幻影现象。事务$T_1$读取数据后，事务$T_2$执行插入或删除操作，使$T_1$无法再现前一次的读取结果。 

#### 3、并发调度的客串行性

```markdown
	以下两条背诵。
```

- <span style='background-color:yellow'>**多个事务的并发执行是正确的，当且仅当结果与某一次序串行地执行它们的结果相同，称这种调度策略是<font color=red>可串行化的调度</font>**。</span>
- <span style='background-color:yellow'>**可串行性是并发事务正确性的准则。即：一个给定的并发调度，当且仅当它是可串行化的才认为是<font color=red>正确调度</font>**</span>



#### 4、并发控制技术

- 并发事务如果对数据读写时不加以控制，会破坏事务的隔离性和一致性。为了保持事务的隔离性，系统必须对事务之间的相互作用加以控制，最典型的方式就是加锁。

  ​	1、排它锁(Exclusive Locks，简称X锁)：<font color=red>也称为写锁，用于对数据进行**写**操作时进行锁定</font>。<span style='background-color:yellow'>如果事务T对数据A加上X锁后，就只允许事务T对数据A进行读取和修改，其他事务对数据A不能再加任何锁，从而也不能读取和修改数据A，直到事务T释放A上的锁。</span>
  ​	2、共享锁 (Share Locks，简称S锁)：<font color=red>也称为读锁，用于对数据进行读操作时进行锁定</font>。<span style='background-color:yellow'>如果事务T对数据A加上了S锁后，事务T就只能读数据A但不可以修改，其他事务可以再对数据A加S锁来读取，只要数据A上有了S锁，但任何事务都只能再对其加S锁读取而不能加X锁修改。</span>

  ```markdown
  	排它锁（X锁/写锁）：A对B加了X锁就只有A能对B读数据、写数据。其他人不能对B加任何锁也不能读和写数据
  	共享锁（S锁/读锁）：能读数据不能改数据，对加了S锁的数据只能加S锁才可以读取，且不能加X锁
  ```

  ```sql
  	XLOCK(A)	//此命令为对A加X锁
  	SLOCK（A）	//此命令为对A加S锁
  ```

  

####  4、封锁协议

1. 一级封锁协议：是指事务T在修改数据A之前必须先对其加X锁，知道事务结束才释放X锁。解决了丢失修改的问题。
2. 二级封锁协议：是一级封锁协议加上事务T在读取数据A之前必须对其加上S锁，读完后即可释放S锁。解决了读脏数据的问题。
3. 三级封锁协议：是一级封锁协议加上事务T在读取数据A之前必须对其加上S锁，直到事务结束才释放S锁。解决了不可重复读的问题。